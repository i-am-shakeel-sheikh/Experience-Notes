its rare that we are interested in single acquisition of data 

Resampling an array

sampling without replacement 

[23.3, 27.1, 24.3, 25.7, 26.0]

Mean : 25.2

Resampled data:

[27.1,26.0,23.3,25.7,23.3]

Mean:25.08

Bootstrapping : use of resampled data to perform statistical inference

Resampling engine 

np.random.choice()

np.random.choice([1,2,3,4,5],size=5)
array([5,3,5,5,2])

bs_sample = np.random.choice(michelson_speed_of_light,size=100)

np.mean(bs_sample)
np.median(bs_sample)
np.std(bs_sample)


you will generate bootstrap samples from the set of annual rainfall data measured at the Sheffield Weather Station in the UK from 1883 to 2015. 
The data are stored in the NumPy array rainfall in units of millimeters (mm). 
By graphically displaying the bootstrap samples with an ECDF, you can get a feel for how bootstrap sampling 
allows probabilistic descriptions of data.


bootstrap confidence intervals 

bootstrap replicate function

def bootstrap_replicate_1d(data,func):
	bs_sample=np.random.choice(data,len(data))
	return func(bs_sample)

bootstrap_replicate_1d(michelson_speed_of_light,np.mean)


bs_replicates = np.empty(10000)

for i in range(10000):
	bs_replicates[i] = bootstrap_replicate_1d(michelson_speed_of_light,np.mean)

plt.hist(bs_replicates,bins=50,normed=True)
plt.xlabel('mean speed of light (km/s)')
plt.ylabel('pdf')
plt.show()

histogram approximates pdf

confidence interval of statistic 

if we repeat measurements over and over again , p% of the observed values would lie within the p% confidence interval 

conf_int = np.percentile(bs_replicates,[2.5,97.5])
array([299837,299868])


def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data,func)

    return bs_replicates
-------------------------------

# Take 10,000 bootstrap replicates of the mean: bs_replicates
bs_replicates = draw_bs_reps(rainfall,np.mean,10000)

# Compute and print SEM
sem = np.std(rainfall) / np.sqrt(len(rainfall))
print(sem)

# Compute and print standard deviation of bootstrap replicates
bs_std = np.std(bs_replicates)
print(bs_std)

# Make a histogram of the results
_ = plt.hist(bs_replicates, bins=50, normed=True)
_ = plt.xlabel('mean annual rainfall (mm)')
_ = plt.ylabel('PDF')

# Show the plot
plt.show()


! Notice that the SEM we got from the known expression 
and the bootstrap replicates is the same and the distribution of the bootstrap replicates of the mean is Normal.

------------------------------

# Generate 10,000 bootstrap replicates of the variance: bs_replicates
bs_replicates = draw_bs_reps(rainfall,np.var,10000)

# Put the variance in units of square centimeters
bs_replicates/=100

# Make a histogram of the results
_ = plt.hist(bs_replicates, bins=50, normed=True)
_ = plt.xlabel('variance of annual rainfall (sq. cm)')
_ = plt.ylabel('PDF')

# Show the plot
plt.show()

This is not normally distributed, as it has a longer tail to the right. 
Note that you can also compute a confidence interval on the variance, or any other statistic, 
using np.percentile() with your bootstrap replicates
---------------------

# Draw bootstrap replicates of the mean no-hitter time (equal to tau): bs_replicates
bs_replicates = draw_bs_reps(nohitter_times,np.mean,10000)

# Compute the 95% confidence interval: conf_int
conf_int = np.percentile(bs_replicates,[2.5,97.5])

# Print the confidence interval
print('95% confidence interval =', conf_int, 'games')

# Plot the histogram of the replicates
_ = plt.hist(bs_replicates, bins=50, normed=True)
_ = plt.xlabel(r'$\tau$ (games)')
_ = plt.ylabel('PDF')

# Show the plot
plt.show()

---------------

This gives you an estimate of what the typical time between no-hitters is. It could be anywhere between 660 and 870 games.

pairs bootstrap 

Non parametric inference 

did not assume about the model or probability distribution underlying the data 


we can perform bootstrap estimates to get confidence intervals on the slope and intercept as well 

total votes vs percent share for obama 

(x,y) is a datapoint 

np.random.choice() must sample 1 D array , we sample indices


np.arange(7)

inds = np.arange(len(total_votes))
bs_inds = np.random.choice(inds,len(inds))

bootstrap sample is generated by slicing out the respective values 
bs_total_votes = total_votes[bs_inds]
bs_dem_share = dem_share[bs_inds]

bs_slope,bs_intercept = np.polyfit(bs_total_votes,bs_dem_share,1)


get many bootstrap replicas and generate confidence intervals to see where are the slope,intercept values lies the most 

--------------------

def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x,bs_y,1)

    return bs_slope_reps, bs_intercept_reps

------------------


# Generate replicates of slope and intercept using pairs bootstrap
bs_slope_reps, bs_intercept_reps = draw_bs_pairs_linreg(illiteracy,fertility,1000)

# Compute and print 95% CI for slope
print(np.percentile(bs_slope_reps, [2.5,97.5]))

# Plot the histogram
_ = plt.hist(bs_slope_reps, bins=50, normed=True)
_ = plt.xlabel('slope')
_ = plt.ylabel('PDF')
plt.show()


plotting bootstrap regressions 

A nice way to visualize the variability we might expect in a linear regression is to plot the line you would get from 
each bootstrap replicate of the slope and intercept. 
Do this for the first 100 of your bootstrap replicates of the slope and intercept (stored as bs_slope_reps and bs_intercept_reps).

# Generate array of x-values for bootstrap lines: x
x = np.array([0,100])

# Plot the bootstrap lines
for i in range(100):
    _ = plt.plot(x, 
                 bs_slope_reps[i]*x + bs_intercept_reps[i],
                 linewidth=0.5, alpha=0.2, color='red')

# Plot the data
_ = plt.plot(illiteracy,fertility,marker='.',linestyle='none')

# Label axes, set the margins, and show the plot
_ = plt.xlabel('illiteracy')
_ = plt.ylabel('fertility')
plt.margins(0.02)
plt.show()